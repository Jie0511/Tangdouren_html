<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>THE MENU - MOBILE PRO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #e0e0e0;
            font-family: 'VT323', 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer;
        }

        #bg-layer {
            position: fixed;
            /* 扩大背景范围，防止旋转时露出黑边 */
            top: -60%; left: -60%; width: 220%; height: 220%;
            z-index: 1;
            background-image: url('./cd_bg.png'), url('./cd_bg.jpg');
            background-size: cover;
            background-position: center;
            filter: blur(4px) brightness(0.7);
            opacity: 1;
            animation: rotateBG 60s linear infinite;
        }

        @keyframes rotateBG {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        #gameCanvas {
            position: relative;
            z-index: 5;
            image-rendering: pixelated; 
            max-width: 100%;
            max-height: 100%;
        }

        .ui-text {
            position: absolute;
            pointer-events: none;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
            font-family: 'VT323', monospace;
        }

        /* 顶部 UI：适配刘海屏安全区域 */
        #top-ui {
            top: max(40px, env(safe-area-inset-top)); 
            width: 100%;
            display: flex;
            justify-content: center;
        }

        #score-box {
            border: 2px solid #fff;
            padding: 5px 20px;
            background: rgba(0,0,0,0.7);
            font-size: 28px;
            color: #4DFF4D;
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(77,255,77,0.5);
        }

        /* 底部提示语：适配底部横条安全区域 */
        #footer-ui {
            bottom: max(100px, calc(15% + env(safe-area-inset-bottom)));
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 14px;
            z-index: 20;
            opacity: 0.6;
            animation: pulseText 2s infinite;
        }

        @keyframes pulseText {
            0% { opacity: 0.3; }
            50% { opacity: 0.8; }
            100% { opacity: 0.3; }
        }

        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(4px); 
            transition: opacity 1.5s ease-out, visibility 1.5s;
        }

        .fade-out {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* 底部大标题：适配底部安全区域 */
        #title-container {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: opacity 1s;
        }

        #menu-subtitle {
            font-size: 16px;
            color: #fff;
            background-color: #4D8FFF;
            display: inline-block;
            padding: 4px 12px;
            margin-bottom: 5px;
            font-weight: bold;
            transform: skew(-10deg);
            white-space: nowrap;
            max-width: 90%;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: 0 0 15px rgba(77, 143, 255, 0.4);
            transition: transform 0.1s;
        }

        #menu-title {
            font-size: 42px; /* 手机上稍微调小一点以免换行 */
            font-weight: bold;
            color: #4D8FFF;
            text-shadow: 0 0 15px rgba(77,143,255,0.8);
            letter-spacing: 4px;
            line-height: 1;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 3px;
            pointer-events: none;
            z-index: 15;
        }
    </style>
</head>
<body>

    <div id="bg-layer"></div>

    <div id="start-screen">
        <h1 style="font-size:40px; color:#4DFF4D; margin-bottom:10px; text-shadow: 0 0 10px #4DFF4D;">THE MENU</h1>
        <p style="font-size:16px; color:#ddd; letter-spacing: 1px;">TOUCH TO START</p>
        <p class="blink" style="font-size:24px; color:#fff; margin-top:20px;">[ SYSTEM READY ]</p>
    </div>

    <div id="top-ui" class="ui-text">
        <div id="score-box">SCORE: <span id="scoreVal" style="color:#4DFF4D">00000</span></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="footer-ui" class="ui-text">
        TAP TO SWITCH TRACK
    </div>

    <div id="title-container">
        <div id="menu-subtitle">01. おうち (EAINT THAN THAR)</div>
        <div id="menu-title">THE MENU</div>
    </div>

    <div class="scanlines"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreVal');
        const startScreen = document.getElementById('start-screen');
        const subtitleEl = document.getElementById('menu-subtitle');
        
        let config = {
            laneCount: 6,
            baseRadius: 0,
            laneGap: 0,
            rotationSpeed: 0.006, 
            playerAngle: Math.PI / 2,
            colors: ['#FF0033', '#FF8800', '#FFEA00', '#00FF44', '#00FFFF', '#CC00FF'],
            dishNames: [
                "01. おうち (EAINT THAN THAR)",
                "02. 糸 (LI JIAYU)",
                "03. 二畳 (SUN JIAHAO)",
                "04. 花園 (TIAN ZHIYUAN)",
                "05. MYSPACE (WANG JIEWEI)",
                "06. LOAM (XU JIAYANG)"
            ]
        };

        let state = {
            isPlaying: false,
            currentLane: 0,
            score: 0,
            foods: [],
            gameTime: 0,
            bgRotation: 0,
            ripples: [] 
        };

        let gameCenterY = 0; 
        let listStartY = 0; // 列表起始位置变量

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let analyser; 
        let dataArray; 
        let bgmInterval;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 64; 
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.connect(audioCtx.destination);
            startBGM();
        }

        function vibratePhone(ms) {
            try { if (navigator.vibrate) navigator.vibrate(ms); } catch(e) {}
        }

        function playScoreSound() {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(analyser); 
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function startBGM() {
            if(!audioCtx || bgmInterval) return;
            const sequence = [220, 0, 261, 0, 329, 0, 293, 0, 196, 0, 220, 0, 392, 0, 329, 0];
            let noteIndex = 0;

            bgmInterval = setInterval(() => {
                if(!state.isPlaying) return;
                const freq = sequence[noteIndex];
                noteIndex = (noteIndex + 1) % sequence.length;
                if (freq > 0) {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    gain.gain.setValueAtTime(0.08, audioCtx.currentTime); 
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.connect(gain);
                    gain.connect(analyser);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                }
                if (noteIndex % 4 === 0) {
                    const kick = audioCtx.createOscillator();
                    const kickGain = audioCtx.createGain();
                    kick.type = 'sine';
                    kick.frequency.setValueAtTime(150, audioCtx.currentTime);
                    kick.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    kickGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    kickGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    kick.connect(kickGain);
                    kickGain.connect(analyser);
                    kick.start();
                    kick.stop(audioCtx.currentTime + 0.5);
                }
            }, 250);
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // --- 手机比例关键调整 ---
            
            // 1. 游戏中心点下移：屏幕高度的 53%
            // 这样上方留出的空间（47%）可以放列表，下方（47%）放标题，手指点击下半部分也更舒服
            gameCenterY = canvas.height * 0.53;
            
            // 2. 列表起始位置：屏幕高度的 15%
            // 避开顶部的 Score 和刘海
            listStartY = canvas.height * 0.15;
            
            // 3. 转盘半径：基于【屏幕宽度】计算
            // 手机是窄屏，所以以宽度为基准。
            // 半径设为宽度的 42%，两边各留 8% 边距，非常饱满
            const maxVisibleRadius = canvas.width * 0.42;
            
            config.laneGap = maxVisibleRadius / (config.laneCount + 1);
            config.baseRadius = config.laneGap * 1.5;
        }
        window.addEventListener('resize', resize);
        resize();

        // 像素水果设计
        const fruitDesigns = [
            { map: ["  2 2  ", "  222  ", " 13111 ", " 11111 ", "  111  ", "   1   "], leafColor: '#00FF00' }, 
            { map: ["  222  ", " 11311 ", "1111111", "1111111", " 11111 ", "  111  "], leafColor: '#00AA00' }, 
            { map: ["   1   ", "  131  ", " 11111 ", " 11111 ", "  111  ", "   1   "], leafColor: '#FFFFFF' }, 
            { map: ["   4   ", "  212  ", " 13111 ", " 11111 ", " 11111 ", "  111  "], leafColor: '#00cc00' }, 
            { map: ["       ", " 13 13 ", " 11 11 ", "       ", "  131  ", "  111  "], leafColor: '#fff' },    
            { map: [" 22222 ", "  131  ", " 11111 ", "  111  ", "   1   ", "       "], leafColor: '#00FF00' }  
        ];
        
        const fruitSprites = fruitDesigns.map((d, i) => {
            const sizeX = d.map[0].length;
            const sizeY = d.map.length;
            const scale = 4;
            const c = document.createElement('canvas');
            c.width = sizeX * scale; 
            c.height = sizeY * scale;
            const xCtx = c.getContext('2d');
            d.map.forEach((row, y) => {
                row.split('').forEach((char, x) => {
                    if (char === ' ') return;
                    if (char === '1') xCtx.fillStyle = config.colors[i]; 
                    else if (char === '2') xCtx.fillStyle = d.leafColor; 
                    else if (char === '3') xCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    else if (char === '4') xCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    xCtx.fillRect(x * scale, y * scale, scale, scale);
                });
            });
            return c;
        });

        class Player {
            draw() {
                const r = config.baseRadius + (state.currentLane + 0.5) * config.laneGap;
                const x = canvas.width / 2 + Math.cos(config.playerAngle) * r;
                const y = gameCenterY + Math.sin(config.playerAngle) * r;
                
                ctx.save();
                const size = 20;
                ctx.fillStyle = '#fff';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 5;
                ctx.fillRect(x - size/2, y - size/2, size, size);
                
                ctx.fillStyle = '#000';
                const eyeSize = 4; 
                ctx.translate(x, y);
                ctx.rotate(config.playerAngle + Math.PI/2); 
                ctx.fillRect(-5, -4, eyeSize, eyeSize);
                ctx.fillRect(1, -4, eyeSize, eyeSize);
                ctx.restore();
            }
        }

        class Food {
            constructor() {
                this.lane = Math.floor(Math.random() * config.laneCount);
                this.angle = config.playerAngle - Math.PI + (Math.random() - 0.5);
                this.active = true;
                this.sprite = fruitSprites[this.lane];
            }
            update() {
                this.angle += config.rotationSpeed;
                let diff = Math.abs(this.angle - config.playerAngle);
                while(diff > Math.PI * 2) diff -= Math.PI * 2;
                
                if (diff < 0.12 && this.active) {
                    if (this.lane === state.currentLane) {
                        state.score += 100;
                        scoreEl.innerText = state.score.toString().padStart(5, '0');
                        this.active = false;
                        playScoreSound();
                        vibratePhone(40);
                    }
                }
                if (this.angle > config.playerAngle + 0.6) { this.active = false; }
            }
            draw() {
                if (!this.active) return;
                const r = config.baseRadius + (this.lane + 0.5) * config.laneGap;
                const cx = canvas.width / 2;
                const cy = gameCenterY;
                const x = cx + Math.cos(this.angle) * r;
                const y = cy + Math.sin(this.angle) * r;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.angle + Math.PI/2);
                ctx.drawImage(this.sprite, -this.sprite.width/2, -this.sprite.height/2);
                ctx.restore();
            }
        }

        const player = new Player();

        function updateUI() {
            const currentSong = config.dishNames[state.currentLane];
            if (subtitleEl.innerText !== currentSong) {
                subtitleEl.innerText = currentSong;
                subtitleEl.style.transform = 'skew(-10deg) scale(1.1)';
                setTimeout(() => {
                    subtitleEl.style.transform = 'skew(-10deg) scale(1)';
                }, 100);
            }
        }

        function createRipple(x, y) {
            state.ripples.push({x: x, y: y, radius: 10, alpha: 1});
        }

        function handleInput(e) {
            if(!state.isPlaying) return;
            
            let x = 0, y = 0;
            if(e.type === 'touchstart' && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else if (e.type === 'mousedown') {
                x = e.clientX;
                y = e.clientY;
            }
            createRipple(x, y);

            state.currentLane++;
            if (state.currentLane >= config.laneCount) { state.currentLane = 0; }
            updateUI();
            
            vibratePhone(15);

            if(audioCtx && audioCtx.state === 'running') {
                 const osc = audioCtx.createOscillator();
                 const gain = audioCtx.createGain();
                 osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                 gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                 gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
                 osc.connect(gain);
                 gain.connect(analyser); 
                 osc.start();
                 osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        startScreen.addEventListener('click', () => {
            state.isPlaying = true;
            startScreen.classList.add('fade-out');
            initAudio(); 
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(err => {});
            }
        });
        
        window.addEventListener('touchstart', (e) => { 
            if(state.isPlaying) { handleInput(e); }
        }, {passive: false});
        
        window.addEventListener('mousedown', (e) => { 
            if(state.isPlaying) handleInput(e); 
        });

        function drawBackground() {
            const cx = canvas.width / 2;
            const cy = gameCenterY; 
            state.bgRotation += config.rotationSpeed * 0.1;

            ctx.save();
            ctx.translate(cx, cy);
            
            for(let i = config.laneCount - 1; i >= 0; i--) {
                const outerRadius = config.baseRadius + (i + 1) * config.laneGap;
                const innerRadius = config.baseRadius + i * config.laneGap;
                
                ctx.beginPath();
                ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                ctx.arc(0, 0, innerRadius, 0, Math.PI * 2, true);
                
                if (i === state.currentLane) {
                    ctx.fillStyle = config.colors[i] + '66'; 
                } else {
                    ctx.fillStyle = config.colors[i] + '22'; 
                }
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(0, 0, (outerRadius + innerRadius) / 2, 0, Math.PI * 2);
                ctx.strokeStyle = config.colors[i] + 'AA'; 
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            const centerRadius = config.baseRadius;
            ctx.beginPath();
            ctx.arc(0, 0, centerRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.restore();
            
            // 列表
            ctx.save();
            ctx.textAlign = 'left';
            
            const listStartX = 20; 
            
            config.dishNames.forEach((name, i) => {
                // 行高设为 28px，适合手机屏幕
                const yPos = listStartY + (i * 28);
                
                if (i === state.currentLane) {
                    ctx.fillStyle = config.colors[i];
                    // 字体大小 16px，加粗，适合手机阅读
                    ctx.font = 'bold 16px "Courier New", monospace';
                    ctx.shadowColor = config.colors[i];
                    ctx.shadowBlur = 10;
                    ctx.fillText("> " + name, listStartX, yPos);
                    
                    const textWidth = ctx.measureText("> " + name).width;
                    // 水果图标也适配文字大小
                    ctx.drawImage(fruitSprites[i], listStartX + textWidth + 8, yPos - 12);
                    
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.25)'; 
                    ctx.font = '14px "Courier New", monospace';
                    ctx.fillText(name, listStartX, yPos);
                }
            });
            ctx.restore();
        }

        function drawVisualizer() {
            if (!analyser) return;
            analyser.getByteFrequencyData(dataArray);
            
            const barWidth = 10; // 窄一点适合手机
            const gap = 4;
            const dataCount = 20; 
            const totalWidth = dataCount * (barWidth + gap);
            const startX = (canvas.width - totalWidth) / 2;
            
            ctx.save();
            
            for (let i = 0; i < dataCount; i++) {
                const value = dataArray[i + 3] || 0; 
                const percent = value / 255;
                const height = percent * 100 + 5; 
                
                const x = startX + i * (barWidth + gap);
                const y = canvas.height - height; 
                
                ctx.fillStyle = 'rgba(77, 143, 255, 0.6)';
                ctx.fillRect(x, y, barWidth, height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(x, y, barWidth, 4);
            }
            ctx.restore();
        }

        function drawRipples() {
            ctx.save();
            ctx.lineWidth = 2;
            for (let i = state.ripples.length - 1; i >= 0; i--) {
                const r = state.ripples[i];
                r.radius += 5;
                r.alpha -= 0.05;
                
                if (r.alpha <= 0) {
                    state.ripples.splice(i, 1);
                } else {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${r.alpha})`;
                    ctx.beginPath();
                    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function applyScreenGlitch() {
            if (Math.random() < 0.02) {
                const glitchHeight = Math.random() * 120 + 20;
                const glitchY = Math.random() * canvas.height;
                const glitchOffset = (Math.random() - 0.5) * 60;
                ctx.drawImage(canvas, 0, glitchY, canvas.width, glitchHeight, glitchOffset, glitchY, canvas.width, glitchHeight);
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                if (Math.random() > 0.5) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    ctx.fillRect(glitchOffset, glitchY, canvas.width, glitchHeight);
                } else {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                    ctx.fillRect(-glitchOffset, glitchY, canvas.width, glitchHeight);
                }
                ctx.restore();
            }
        }

        function loop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();
            
            if (state.isPlaying) {
                if (state.gameTime % 50 === 0) { state.foods.push(new Food()); }
                for (let i = state.foods.length - 1; i >= 0; i--) {
                    state.foods[i].update();
                    state.foods[i].draw();
                    if (!state.foods[i].active) { state.foods.splice(i, 1); }
                }
                state.gameTime++;
                
                drawVisualizer();
                drawRipples(); 
            }
            
            player.draw();
            if (state.isPlaying) { applyScreenGlitch(); }
            requestAnimationFrame(loop);
        }

        loop();

    </script>
</body>
</html>
